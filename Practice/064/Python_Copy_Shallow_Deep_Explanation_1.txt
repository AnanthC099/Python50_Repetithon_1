> * **Code line** = what you typed
> * **Output line** = what Python printed/returned
> * **Error line** = exception / syntax error text

---

# 0) Interpreter / Environment (Banner)

### Lines

```
Python 3.14.0 (tags/v3.14.0:ebf955d, Oct  7 2025, 10:15:03) [MSC v.1944 64 bit (AMD64)] on win32
Enter "help" below or click "Help" above for more information.
```

### Concept

* Shows **Python version**, build details, and OS platform (`win32` here).
* Not part of your program logic; just IDLE’s startup banner.

---

# 1) Concept: Assignment creates a **reference** (aliasing) — Immutable (`bool`)

### Lines

```python
b1 = True
b2 = b1
id(b1)
140734956161792
id(b2)
140734956161792
```

### Line-by-line

* `b1 = True` → `b1` now refers to the **bool object** `True`.
* `b2 = b1` → `b2` refers to the **same object** as `b1` (no copy).
* `id(b1)` → asks identity of object referenced by `b1`.
* `140734956161792` → output: identity value for `True`.
* `id(b2)` → asks identity of object referenced by `b2`.
* `140734956161792` → output: same identity ⇒ `b1` and `b2` point to **same object**.

---

# 2) Concept: Assignment creates a **reference** (aliasing) — Mutable (`list`)

### Lines

```python
L1 = [10, 20, 30]
L2 = L1
id(L1)
2339489160320
id(L2)
2339489160320
```

### Line-by-line

* `L1 = [10, 20, 30]` → creates a **new list object**, `L1` refers to it.
* `L2 = L1` → aliasing: `L2` refers to the **same list** object.
* `id(L1)` → identity of that list object.
* `2339489160320` → output id for list referenced by `L1`.
* `id(L2)` → identity of list referenced by `L2`.
* `2339489160320` → same id ⇒ same list object shared by both names.

---

# 3) Comments / separators (they do nothing at runtime)

### Lines

```python
#-------------------------

#-------------------------
# Mutable objects can be cloned explicitly.
# Implicit cloning
```

### Concept

* These are **comments**. Python ignores them.
* They’re just separators + headings for your explanation.

---

# 4) Concept: Two variables can have **equal values** but be **different objects** (`==` vs `is`) — Float example

### Lines

```python
n = 1.1
m = 1.1
print(m)
1.1
print(n)
1.1
id(m)
2339488155184
id(n)
2339488155120
m == n
True
m is n
False
```

### Line-by-line

* `n = 1.1` → `n` refers to a float object (value 1.1).
* `m = 1.1` → often creates another float object (same value, different identity).
* `print(m)` → prints value of `m`.
* `1.1` → output.
* `print(n)` → prints value of `n`.
* `1.1` → output.
* `id(m)` → identity of float object `m`.
* `2339488155184` → output id.
* `id(n)` → identity of float object `n`.
* `2339488155120` → different id ⇒ different objects.
* `m == n` → checks **value equality**.
* `True` → values are equal (both 1.1).
* `m is n` → checks **object identity** (same object?).
* `False` → not the same object.

---

# 5) Separator comment

### Lines

```python
#-------------------------
```

### Concept

* Just a separator comment again.

---

# 6) Concept: Explicit cloning with `.copy()` (Shallow copy) — List

### Lines

```python
# Explicit cloning using copy method
L = [10, 20, 30]
L1 = L.copy()
L == L1
True
L
[10, 20, 30]
L1
[10, 20, 30]
id(L)
2339489282496
id(L1)
2339489167552
L is L1
False
```

### Line-by-line

* `# Explicit cloning using copy method` → comment heading.
* `L = [10, 20, 30]` → creates a list object.
* `L1 = L.copy()` → creates a **new list object** with same elements (**shallow copy**).
* `L == L1` → compares values/contents.
* `True` → same contents.
* `L` → show L in REPL.
* `[10, 20, 30]` → output.
* `L1` → show L1 in REPL.
* `[10, 20, 30]` → output.
* `id(L)` → identity of original list.
* `2339489282496` → output.
* `id(L1)` → identity of copied list.
* `2339489167552` → different id ⇒ different list objects.
* `L is L1` → identity comparison.
* `False` → confirms they are different objects.

---

# 7) Concept: `.copy()` (Shallow copy) — Dict

### Lines

```python
D1 = {'a' : 10, 'b': 20, 'c' : 30}
D2 = D1.copy()
id(D1)
2339489218496
id(D2)
2339489218304
D1 == D2
True
D1 is D2
False
```

### Line-by-line

* `D1 = {...}` → creates a dict object.
* `D2 = D1.copy()` → new dict object, shallow copy.
* `id(D1)` → id of original dict.
* `2339489218496` → output.
* `id(D2)` → id of copied dict.
* `2339489218304` → different id.
* `D1 == D2` → same key/value content?
* `True` → yes.
* `D1 is D2` → same object?
* `False` → no.

---

# 8) Concept: `.copy()` (Shallow copy) — Set

### Lines

```python
S1 = {100, 200, 300}
S2 = S1.copy()
S1 == S2
True
S1 is S2
False
```

### Line-by-line

* `S1 = {...}` → creates a set object.
* `S2 = S1.copy()` → new set object (shallow copy).
* `S1 == S2` → same elements?
* `True` → yes.
* `S1 is S2` → same object?
* `False` → no.

---

# 9) Concept: Why immutables don’t have `.copy()` (AttributeError) + One SyntaxError demo

### Lines (bool)

```python
b1 = False
b1.copy()
Traceback (most recent call last):
  File "<pyshell#39>", line 1, in <module>
    b1.copy()
AttributeError: 'bool' object has no attribute 'copy'
```

* `b1 = False` → b1 refers to `False`.
* `b1.copy()` → tries to call `.copy()` on a bool.
* Traceback… → Python error report.
* `AttributeError...` → bool has no `.copy()` because bool is **immutable**.

### Lines (int)

```python
n = 100
n.copy()
Traceback (most recent call last):
  File "<pyshell#41>", line 1, in <module>
    n.copy()
AttributeError: 'int' object has no attribute 'copy'
```

* int is immutable → no `.copy()`.

### Lines (float)

```python
f_num = 1.1
f_num.copy()
Traceback (most recent call last):
  File "<pyshell#43>", line 1, in <module>
    f_num.copy()
AttributeError: 'float' object has no attribute 'copy'
```

* float is immutable → no `.copy()`.

### Lines (string mistake → SyntaxError)

```python
s1 = "Hello
SyntaxError: unterminated string literal (detected at line 1)
```

* `s1 = "Hello` → missing closing `"` quote.
* Python stops parsing and raises **SyntaxError**: unterminated string.

### Lines (str correct + copy error)

```python
s1 = "Hello"
s1.copy()
Traceback (most recent call last):
  File "<pyshell#46>", line 1, in <module>
    s1.copy()
AttributeError: 'str' object has no attribute 'copy'
```

* Correct string assignment.
* `str` is immutable → no `.copy()`.

### Lines (tuple)

```python
T = (100, 200, 300)
T.copy()
Traceback (most recent call last):
  File "<pyshell#48>", line 1, in <module>
    T.copy()
AttributeError: 'tuple' object has no attribute 'copy'
```

* tuple is immutable → no `.copy()`.

---

# 10) Concept: `.copy()` is **shallow copy** (outer copied, inner references shared)

### Lines

```python
# ARGUMENT -> COPY FUNCTION IS A SHALLOW VERSION OF DEEP COPYING
L1 = [10, 20, 30, 40]
L2 = L1.copy()
id(L1)
2339488325696
id(L2)
2339489381952
L1 is L2
False
L1 == L2
True
```

### Line-by-line

* Comment: `.copy()` is shallow.
* `L1 = [10, 20, 30, 40]` → list of immutable ints.
* `L2 = L1.copy()` → new list (outer container copied).
* `id(L1)` / output → id of original list.
* `id(L2)` / output → id of copied list (different).
* `L1 is L2` / `False` → not same list object.
* `L1 == L2` / `True` → same contents.

---

# 11) Concept: Shallow copy shares **element objects** (safe here because ints are immutable)

### Lines (loop over L1)

```python
for x in L1:
    print(x, id(x))

    
10 140734957069720
20 140734957070040
30 140734957070360
40 140734957070680
```

### Line-by-line

* `for x in L1:` → iterates elements in `L1`.
* `print(x, id(x))` → prints element value and identity.
* Blank lines → IDLE formatting (no meaning).
* Output lines show ids of each int object.

### Lines (loop over L2)

```python
for x in L2:
    print(x, id(x))

    
10 140734957069720
20 140734957070040
30 140734957070360
40 140734957070680
```

### Meaning

* Same ids for 10/20/30/40 in both loops → shallow copy reused same int objects.
* Safe because ints are **immutable**.

### Your comment lines (included)

```python
# as 10, 20, 30, 40 all are immutable objects, them being shared across L1 & L2 is NOT PARTICULARLY PROBLEMETIC
# IF A LIST CONTAINS A MUTABLE OBJECT INSIDE IT THEN IT BECOMES PROBLEMETIC
```

* Correct explanation: sharing immutable elements is fine; sharing mutable nested objects is risky.

---

# 12) Concept: Shallow copy becomes **problematic** with nested mutable objects (inner list shared)

### Lines

```python
L1 = [10, 20, 30, [100, 200, 300], 40]
L2 = L1.copy()
id(L1)
2339489167936
id(L2)
2339488325696
L1 is L2
False
L1 == L2
True
L1[3]
[100, 200, 300]
L2[3]
[100, 200, 300]
id(L1[3])
2339444617088
id(L2[3])
2339444617088
L1[3].append(400)
L2
[10, 20, 30, [100, 200, 300, 400], 40]
```

### Line-by-line

* `L1 = [10, 20, 30, [100, 200, 300], 40]` → list contains a **nested list** at index 3.
* `L2 = L1.copy()` → new outer list, but inner objects are shared (shallow).
* `id(L1)` / output → id of outer list 1.
* `id(L2)` / output → id of outer list 2 (different).
* `L1 is L2` / `False` → outer lists are different.
* `L1 == L2` / `True` → contents equal.
* `L1[3]` / output → shows the nested list.
* `L2[3]` / output → shows the nested list (looks same).
* `id(L1[3])` / output → id of nested list in L1.
* `id(L2[3])` / output → **same id** ⇒ nested list object is shared.
* `L1[3].append(400)` → mutates nested list in-place.
* `L2` / output → shows change appears in L2 too because nested list is shared.

---

# 13) Concept: Deep copy fixes nested mutable sharing (`copy.deepcopy`)

### Lines

```python
>>> import copy
>>> L1 = [10, 20, 30, [100, 200, 300], 40]
>>> L2 = copy.deepcopy(L1)
>>> id(L1)
2339489410304
>>> id(L2)
2339489167488
>>> id(L1[0])
140734957069720
>>> id(L2[0])
140734957069720
>>> id(L1[1])
140734957070040
>>> id(L2[1])
140734957070040
>>> id(L1[2])
140734957070360
>>> id(L2[2])
140734957070360
>>> id(L1[3])
2339489409344
>>> id(L2[3])
2339489160320
>>> L1[3].append(400)
>>> L2
[10, 20, 30, [100, 200, 300], 40]
>>> L1
[10, 20, 30, [100, 200, 300, 400], 40]
>>> L1[3]
[100, 200, 300, 400]
>>> L2[3]
[100, 200, 300]
>>> id(L1[3][0])
140734957072600
>>> id(L2[3][0])
140734957072600
```

### Line-by-line

* `>>> import copy` → imports the `copy` module.
* `>>> L1 = ...` → recreates nested list.
* `>>> L2 = copy.deepcopy(L1)` → deep copy: copies outer list **and** nested list.
* `>>> id(L1)` / output → id of original outer list.
* `>>> id(L2)` / output → id of copied outer list (different).
* `>>> id(L1[0])` / output and `>>> id(L2[0])` / output
  → element `10` is immutable; deep copy may reuse same int object safely.
* Same pattern for indices `[1]` and `[2]` (20, 30).
* `>>> id(L1[3])` / output → id of nested list in L1.
* `>>> id(L2[3])` / output → different id ⇒ nested list was copied too ✅
* `>>> L1[3].append(400)` → mutate nested list inside L1.
* `>>> L2` / output → unchanged (deep copy worked).
* `>>> L1` / output → changed (only original mutated).
* `>>> L1[3]` / output → shows `[100, 200, 300, 400]`.
* `>>> L2[3]` / output → shows `[100, 200, 300]`.
* `>>> id(L1[3][0])` and `>>> id(L2[3][0])`
  → both are `100` (immutable int), so ids can match; deep copy doesn’t need duplicate immutables.

---

## Final teaching one-liner (ties all blocks together)

* `=` **aliases** (no copy)
* `==` checks **value**, `is` checks **same object**
* `.copy()` copies **outer container only** (**shallow**)
* `copy.deepcopy()` copies **nested mutable objects too** (**deep**)

